<?xml version="1.0"?>
<ruleset name="Verificatum ruleset"
         xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">

  <description>
    Ruleset used by PDM to analyze VECJ. Please read the comments to
    see what rules have been commented out and why.
  </description>

  <!-- ############################################################## -->

  <!-- Some of the rules below gives false positives that can not be
       filtered out with properties of the rules, so this is done
       using grep in the pmd_filter.sh script. -->

  <!-- ############################################################## -->

  <rule ref="rulesets/java/braces.xml"/>

  <!-- ############################################################## -->

  <rule ref="rulesets/java/clone.xml"/>

  <!-- ############################################################## -->

  <rule ref="rulesets/java/unnecessary.xml"/>

  <!-- ############################################################## -->

  <!-- This is implemented incorrectly. It treats comparison with
       strings and chars in the same way, despite that comparison can
       not be invoked from a char. -->
  <rule ref="rulesets/java/unusedcode.xml"/>

  <!-- ############################################################## -->

  <rule ref="rulesets/java/typeresolution.xml/LooseCoupling"/>
  <rule ref="rulesets/java/typeresolution.xml/CloneMethodMustImplementCloneable"/>
  <rule ref="rulesets/java/typeresolution.xml/UnusedImports"/>
  <!-- In testing and demo code it is natural to declare methods to
       throw very general Throwable objects. We filter out the
       irrelevant exceptions with a command-line filter. -->
  <rule ref="rulesets/java/typeresolution.xml/SignatureDeclareThrowsException"/>

  <!-- ############################################################## -->

  <!-- In testing and demo code it is natural to capture any type of
       Throwable object. We filter out the irrelevant captures with a
       command-line filter. -->
  <rule ref="rulesets/java/strictexception.xml/AvoidCatchingThrowable"/>
  <rule ref="rulesets/java/strictexception.xml/SignatureDeclareThrowsException"/>
  <!-- It is natural to use "exceptions as control flow statements" at
       the top level in classes used directly by users. We filter out
       these cases in the command-line filter. -->
  <rule ref="rulesets/java/strictexception.xml/ExceptionAsFlowControl"/>
  <rule ref="rulesets/java/strictexception.xml/AvoidCatchingNPE"/>
  <rule ref="rulesets/java/strictexception.xml/AvoidThrowingRawExceptionTypes"/>
  <rule ref="rulesets/java/strictexception.xml/AvoidThrowingNullPointerException"/>
  <rule ref="rulesets/java/strictexception.xml/AvoidRethrowingException"/>
  <!-- This rule is wrong. There are certainly cases where it makes
       sense to extend java.lang.Error.
       <rule ref="rulesets/java/strictexception.xml/DoNotExtendJavaLangError"/>
       -->
       <rule ref="rulesets/java/strictexception.xml/DoNotThrowExceptionInFinally"/>
       <rule ref="rulesets/java/strictexception.xml/AvoidThrowingNewInstanceOfSameException"/>
       <!-- In testing and demo code it is natural to capture any type of
            Throwable object. We filter out the irrelevant captures with a
            command-line filter. -->
       <rule ref="rulesets/java/strictexception.xml/AvoidCatchingGenericException"/>
       <rule ref="rulesets/java/strictexception.xml/AvoidLosingExceptionInformation"/>

       <!-- ############################################################## -->

       <!-- I am sure there are cases where I violate Demeter's rule in a
            meaningful way, but seriously, complaining about access of
            elements in a collection passed to a method?! It is *natural*
            to create a bunch of classes that mutually peek inside each
            other. This rule should be removed from PMD because it catches
            way too much.
            <rule ref="rulesets/java/coupling.xml"/>
            -->

            <!-- ############################################################## -->

            <rule ref="rulesets/java/controversial.xml/UnnecessaryConstructor"/>
            <!-- In this code this is mostly used as a signal to the garbage
                 collector that a large object can be collected and sometimes it
                 is used as a joint data reference or flag that there is nothing
                 to reference. Thus, we ignore this rule.
                 <rule ref="rulesets/java/controversial.xml/NullAssignment"/>
                 -->
                 <!-- Another layer of conditional code to have a single point of
                      return does not improve code quality, so we ignore this rule.
                      <rule ref="rulesets/java/controversial.xml/OnlyOneReturn"/>
                 -->
                 <!-- This rule is not found by PMD?!!
                      <rule ref="rulesets/java/controversial.xml/UnusedModifier"/>
                 -->
                 <rule ref="rulesets/java/controversial.xml/AssignmentInOperand"/>

                 <!-- This clutters the code more than it helps.
                      <rule ref="rulesets/java/controversial.xml/AtLeastOneConstructor"/>
                 -->

                 <rule ref="rulesets/java/controversial.xml/DontImportSun"/>
                 <rule ref="rulesets/java/controversial.xml/SuspiciousOctalEscape"/>
                 <!-- This rule is wrong, so we ignore it. Superclass constructors
                      are implicitly called in almost all object oriented languages.
                      <rule ref="rulesets/java/controversial.xml/CallSuperInConstructor"/>
                 -->

                 <rule ref="rulesets/java/controversial.xml/UnnecessaryParentheses"/>
                 <!-- This rule is wrong, so we ignore it. Package scoping is explicit.
                      <rule ref="rulesets/java/controversial.xml/DefaultPackage"/>
                 -->
                 <!-- This rule is wrong, so we ignore it. Taking the complement
                      using ! is natural.
                      <rule ref="rulesets/java/controversial.xml/BooleanInversion"/>
                 -->
                 <!-- This is incorrectly implemented, so we ignore it.
                      <rule ref="rulesets/java/controversial.xml/DataflowAnomalyAnalysis"/>
                 -->
                 <!-- This rule is wrong, so we ignore it. One would expect any
                      local variables to be *local* and any variables/parameters that
                      are only assigned a value once should be declared final and it
                      does make a lot of sense to use final local variables for
                      increased readability.
                      <rule ref="rulesets/java/controversial.xml/AvoidFinalLocalVariable"/>
                 -->
                 <!-- The processing of shorts should of course be kept in mind, and
                      this rule may serve as a reminder, but it does not make sense
                      as a general rule.
                      <rule ref="rulesets/java/controversial.xml/AvoidUsingShortType"/>
                 -->
                 <rule ref="rulesets/java/controversial.xml/AvoidUsingVolatile"/>

                 <!-- This rule is wrong, so we ignore it. Fast cryptocode must
                      be written in native code.
                      <rule ref="rulesets/java/controversial.xml/AvoidUsingNativeCode"/>
                 -->
                 <rule ref="rulesets/java/controversial.xml/AvoidAccessibilityAlteration"/>
                 <rule ref="rulesets/java/controversial.xml/DoNotCallGarbageCollectionExplicitly"/>

                 <!-- This rule is wrong, so we ignore it. A reasonably good
                      programmer can tell the difference between a literal that
                      should be named and defined as a static variable and those that
                      make sense on their own. Thus, this rule casts a too wide net.
                      <rule ref="rulesets/java/controversial.xml/AvoidLiteralsInIfCondition"/>
                      -->
                      <rule ref="rulesets/java/controversial.xml/UseConcurrentHashMap"/>

                      <!-- ############################################################## -->

                      <rule ref="rulesets/java/codesize.xml/CyclomaticComplexity">
                        <properties>
                          <property name="reportLevel" value="11"/>

                          <!-- Each method that matches this pattern is automatically
                               generated. -->
                          <property name="violationSuppressRegex" value=".*MillerRabinTrial.*|.*trial.*|.*safeTrial.*"/>

                        </properties>
                      </rule>
                      <rule ref="rulesets/java/codesize.xml/NcssTypeCount">
                        <properties>

                          <!-- Each method that matches this pattern is automatically
                               generated. -->
                          <property name="violationSuppressRegex" value=".*trial.*|.*safeTrial.*"/>
                        </properties>
                      </rule>
                      <rule ref="rulesets/java/codesize.xml/NcssMethodCount">
                        <properties>

                          <!-- Each method that matches this pattern is automatically
                               generated. -->
                          <property name="violationSuppressRegex" value=".*MillerRabinTrial.*|.*trial.*|.*safeTrial.*"/>

                        </properties>
                      </rule>
                      <rule ref="rulesets/java/codesize.xml/NcssTypeCount">
                        <properties>

                          <!-- Each method of classes that matches this pattern is
                               automatically generated. -->
                          <property name="violationSuppressXPath" value=".[typeof('com.verificatum.arithm.MillerRabinTrial')]"/>

                        </properties>
                      </rule>
                      <!-- This rule makes no sense in a language like Java where
                           functions are grouped by classes, so we ignore it.
                           <rule ref="rulesets/java/codesize.xml/TooManyMethods"/>
                      -->

                      <!-- ############################################################## -->

                      <!-- This is buggy, since it complains about comments that are
                           inherited from superclasses.
                           <rule ref="rulesets/java/comments.xml/CommentRequired"/>
                      -->

                      <!-- Long comments are long for a reason in Verificatum. The idea of
                           restricting the length of a comment in general is fundamentally
                           wrong. Furthermore, security critical code should be commented
                           carefully.
                           <rule ref="rulesets/java/comments.xml/CommentSize"/>
                      -->
                      <rule ref="rulesets/java/comments.xml/CommentContent"/>

                      <!-- ############################################################## -->

                      <!-- Seems to be removed as of version 1.0.3
                           <rule ref="rulesets/java/design.xml/UseSingleton"/> -->

                      <rule ref="rulesets/java/design.xml/SimplifyBooleanReturns"/>
                      <rule ref="rulesets/java/design.xml/SimplifyBooleanExpressions"/>
                      <rule ref="rulesets/java/design.xml/SwitchStmtsShouldHaveDefault"/>
                      <rule ref="rulesets/java/design.xml/AvoidDeeplyNestedIfStmts"/>
                      <rule ref="rulesets/java/design.xml/AvoidReassigningParameters"/>
                      <rule ref="rulesets/java/design.xml/SwitchDensity"/>
                      <!-- This rule is wrong, so we ignore it. It is perfectly fine to
                           call an overridable function during construction.
                           <rule ref="rulesets/java/design.xml/ConstructorCallsOverridableMethod"/>
                           -->
                           <rule ref="rulesets/java/design.xml/AccessorClassGeneration"/>
                           <rule ref="rulesets/java/design.xml/FinalFieldCouldBeStatic"/>
                           <rule ref="rulesets/java/design.xml/CloseResource"/>
                           <rule ref="rulesets/java/design.xml/NonStaticInitializer"/>
                           <rule ref="rulesets/java/design.xml/DefaultLabelNotLastInSwitchStmt"/>
                           <rule ref="rulesets/java/design.xml/NonCaseLabelInSwitchStatement"/>
                           <rule ref="rulesets/java/design.xml/OptimizableToArrayCall"/>
                           <rule ref="rulesets/java/design.xml/EqualsNull"/>
                           <rule ref="rulesets/java/design.xml/ConfusingTernary"/>
                           <rule ref="rulesets/java/design.xml/InstantiationToGetClass"/>
                           <rule ref="rulesets/java/design.xml/IdempotentOperations"/>

                           <!-- This is implemented correctly. It complains even when an explicit
                                format string is given. -->
                           <!-- <rule ref="rulesets/java/design.xml/SimpleDateFormatNeedsLocale"/> -->
                           <rule ref="rulesets/java/design.xml/ImmutableField"/>
                           <rule ref="rulesets/java/design.xml/UseLocaleWithCaseConversions"/>
                           <rule ref="rulesets/java/design.xml/AvoidProtectedFieldInFinalClass"/>
                           <rule ref="rulesets/java/design.xml/AssignmentToNonFinalStatic"/>
                           <rule ref="rulesets/java/design.xml/MissingStaticMethodInNonInstantiatableClass"/>
                           <rule ref="rulesets/java/design.xml/AvoidSynchronizedAtMethodLevel"/>
                           <rule ref="rulesets/java/design.xml/MissingBreakInSwitch"/>
                           <rule ref="rulesets/java/design.xml/UseNotifyAllInsteadOfNotify"/>
                           <rule ref="rulesets/java/design.xml/AvoidInstanceofChecksInCatchClause"/>
                           <rule ref="rulesets/java/design.xml/AbstractClassWithoutAbstractMethod"/>
                           <rule ref="rulesets/java/design.xml/SimplifyConditional"/>
                           <rule ref="rulesets/java/design.xml/SimplifyConditional"/>
                           <rule ref="rulesets/java/design.xml/PositionLiteralsFirstInComparisons"/>
                           <rule ref="rulesets/java/design.xml/UnnecessaryLocalBeforeReturn"/>
                           <rule ref="rulesets/java/design.xml/NonThreadSafeSingleton"/>
                           <!-- This test is implemented incorrectly, so we ignore it.
                                <rule ref="rulesets/java/design.xml/UncommentedEmptyMethod"/>
                                -->
                                <rule ref="rulesets/java/design.xml/UncommentedEmptyConstructor"/>
                                <rule ref="rulesets/java/design.xml/AvoidConstantsInterface"/>
                                <rule ref="rulesets/java/design.xml/UnsynchronizedStaticDateFormatter"/>
                                <rule ref="rulesets/java/design.xml/PreserveStackTrace"/>
                                <rule ref="rulesets/java/design.xml/UseCollectionIsEmpty"/>
                                <rule ref="rulesets/java/design.xml/ClassWithOnlyPrivateConstructorsShouldBeFinal"/>
                                <rule ref="rulesets/java/design.xml/EmptyMethodInAbstractClassShouldBeAbstract"/>
                                <!-- This only gives a small number of false positives with no
                                     possibilities to filter out specific classes.
                                     <rule ref="rulesets/java/design.xml/SingularField">
                                -->
                                <rule ref="rulesets/java/design.xml/ReturnEmptyArrayRatherThanNull"/>
                                <rule ref="rulesets/java/design.xml/AbstractClassWithoutAnyMethod"/>
                                <rule ref="rulesets/java/design.xml/TooFewBranchesForASwitchStatement"/>

                                <!-- ############################################################## -->

                                <rule ref="rulesets/java/empty.xml"/>

                                <!-- ############################################################## -->

                                <rule ref="rulesets/java/finalizers.xml"/>

                                <!-- ############################################################## -->

                                <rule ref="rulesets/java/imports.xml"/>

                                <!-- ############################################################## -->

                                <!-- This rule is wrong, so we ignore it. Short variable names
                                     are often natural.
                                     <rule ref="rulesets/java/naming.xml/ShortVariable"/>
                                -->
                                <!-- This rule is wrong, so we ignore it. Long variable names
                                     are often natural.
                                     <rule ref="rulesets/java/naming.xml/LongVariable"/>
                                -->
                                <rule ref="rulesets/java/naming.xml/ShortMethodName"/>
                                <rule ref="rulesets/java/naming.xml/VariableNamingConventions"/>
                                <rule ref="rulesets/java/naming.xml/MethodNamingConventions"/>
                                <rule ref="rulesets/java/naming.xml/ClassNamingConventions"/>
                                <!-- This rule is wrong, so we ignore it. It makes no sense to
                                     force all abstract classes to use "Abstract" as a prefix of
                                     their name.
                                     <rule ref="rulesets/java/naming.xml/AbstractNaming"/>
                                     -->
                                     <rule ref="rulesets/java/naming.xml/AvoidDollarSigns"/>
                                     <rule ref="rulesets/java/naming.xml/MethodWithSameNameAsEnclosingClass"/>
                                     <rule ref="rulesets/java/naming.xml/SuspiciousHashcodeMethodName"/>
                                     <!-- This is a subset of the reverse of VariableNamingConventions,
                                          so we ignore it.
                                          <rule ref="rulesets/java/naming.xml/SuspiciousConstantFieldName"/>
                                     -->
                                     <rule ref="rulesets/java/naming.xml/SuspiciousEqualsMethodName"/>
                                     <rule ref="rulesets/java/naming.xml/AvoidFieldNameMatchingTypeName"/>
                                     <!-- This is incorrectly implemented, so we ignore it.
                                          <rule ref="rulesets/java/naming.xml/AvoidFieldNameMatchingMethodName"/>
                                     -->
                                     <!-- This is incorrectly implemented, so we ignore it.
                                          <rule ref="rulesets/java/naming.xml/NoPackage"/>
                                     -->
                                     <rule ref="rulesets/java/naming.xml/PackageCase"/>
                                     <rule ref="rulesets/java/naming.xml/MisleadingVariableName"/>
                                     <!-- This is incorrectly implemented, so we ignore it.
                                          <rule ref="rulesets/java/naming.xml/BooleanGetMethodName"/>
                                     -->
                                     <rule ref="rulesets/java/naming.xml/GenericsNaming"/>

                                     <!-- ############################################################## -->

                                     <rule ref="rulesets/java/optimizations.xml/LocalVariableCouldBeFinal"/>

                                     <!-- ############################################################## -->

                                     <rule ref="rulesets/java/optimizations.xml/MethodArgumentCouldBeFinal"/>
                                     <!-- This rule is wrong, so we ignore it. It is natural to
                                          instantiate objects in loops.
                                          <rule ref="rulesets/java/optimizations.xml/AvoidInstantiatingObjectsInLoops"/>
                                     -->
                                     <rule ref="rulesets/java/optimizations.xml/UseArrayListInsteadOfVector"/>
                                     <rule ref="rulesets/java/optimizations.xml/SimplifyStartsWith"/>
                                     <rule ref="rulesets/java/optimizations.xml/UseStringBufferForStringAppends"/>
                                     <rule ref="rulesets/java/optimizations.xml/UseArraysAsList"/>
                                     <rule ref="rulesets/java/optimizations.xml/AvoidArrayLoops"/>
                                     <rule ref="rulesets/java/optimizations.xml/UnnecessaryWrapperObjectCreation"/>
                                     <rule ref="rulesets/java/optimizations.xml/AddEmptyString"/>

                                     <!-- ############################################################## -->

                                     <rule ref="rulesets/java/sunsecure.xml"/>

                                     <!-- ############################################################## -->

                                     <rule ref="rulesets/java/strings.xml/AvoidDuplicateLiterals">
                                       <properties>

                                         <!-- We filter out repetitions of information and error texts as
                                              well as command line flags and boolean files.-->
                                         <property name="violationSuppressRegex" value=".*(\\n)+.*|.*-.*|.*(  )+.*|.*\..*"/>

                                       </properties>
                                     </rule>
                                     <rule ref="rulesets/java/strings.xml/StringInstantiation"/>
                                     <rule ref="rulesets/java/strings.xml/StringToString"/>
                                     <rule ref="rulesets/java/strings.xml/InefficientStringBuffering"/>
                                     <rule ref="rulesets/java/strings.xml/UnnecessaryCaseChange"/>
                                     <rule ref="rulesets/java/strings.xml/UseStringBufferLength"/>
                                     <rule ref="rulesets/java/strings.xml/AppendCharacterWithChar"/>

                                   </ruleset>
