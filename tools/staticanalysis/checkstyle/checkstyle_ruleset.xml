<?xml version="1.0"?>
<ruleset name="Verificatum ruleset"
         xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">

  <description>
    Ruleset used by PDM to analyze Verificatum.
  </description>

  <!-- ############################################################## -->

  <!-- Some of the rules below gives false positives that can not be
       filtered out with properties of the rules, so this is done
       using grep in the pmd_filter.sh script. -->

  <!-- ############################################################## -->

  <rule ref="rulesets/java/basic.xml">

    <!-- PMD does not understand that hashCode can be computed by a
         method defined in a superclass which uses methods in this
         class. -->
    <exclude name="OverrideBothEqualsAndHashcode"/>
  </rule>

  <!-- ############################################################## -->

  <rule ref="rulesets/java/braces.xml"/>

  <!-- ############################################################## -->

  <rule ref="rulesets/java/clone.xml"/>

  <!-- ############################################################## -->

  <rule ref="rulesets/java/unnecessary.xml"/>

  <!-- ############################################################## -->

  <!-- This is implemented incorrectly. It treats comparison with
       strings and chars in the same way, despite that comparison can
       not be invoked from a char. -->
  <rule ref="rulesets/java/unusedcode.xml"/>

  <!-- ############################################################## -->

  <rule ref="rulesets/java/typeresolution.xml/LooseCoupling"/>
  <rule ref="rulesets/java/typeresolution.xml/CloneMethodMustImplementCloneable"/>
  <rule ref="rulesets/java/typeresolution.xml/UnusedImports"/>
  <!-- In testing and demo code it is natural to declare methods to
       throw very general Throwable objects. We filter out the
       irrelevant exceptions with a command-line filter. -->
  <rule ref="rulesets/java/typeresolution.xml/SignatureDeclareThrowsException"/>

  <!-- ############################################################## -->

  <!-- In testing and demo code it is natural to capture any type of
       Throwable object. We filter out the irrelevant captures with a
       command-line filter. -->
  <rule ref="rulesets/java/strictexception.xml/AvoidCatchingThrowable"/>
  <rule ref="rulesets/java/strictexception.xml/SignatureDeclareThrowsException"/>
  <!-- It is natural to use "exceptions as control flow statements" at
       the top level in classes used directly by users. We filter out
       these cases in the command-line filter. -->
  <rule ref="rulesets/java/strictexception.xml/ExceptionAsFlowControl"/>
  <rule ref="rulesets/java/strictexception.xml/AvoidCatchingNPE"/>
  <rule ref="rulesets/java/strictexception.xml/AvoidThrowingRawExceptionTypes"/>
  <rule ref="rulesets/java/strictexception.xml/AvoidThrowingNullPointerException"/>
  <rule ref="rulesets/java/strictexception.xml/AvoidRethrowingException"/>
  <!-- This rule is wrong. There are certainly cases where it makes
       sense to extend java.lang.Error.
       <rule ref="rulesets/java/strictexception.xml/DoNotExtendJavaLangError"/>
  -->
  <rule ref="rulesets/java/strictexception.xml/DoNotThrowExceptionInFinally"/>
  <rule ref="rulesets/java/strictexception.xml/AvoidThrowingNewInstanceOfSameException"/>
  <!-- In testing and demo code it is natural to capture any type of
       Throwable object. We filter out the irrelevant captures with a
       command-line filter. -->
  <rule ref="rulesets/java/strictexception.xml/AvoidCatchingGenericException"/>
  <rule ref="rulesets/java/strictexception.xml/AvoidLosingExceptionInformation"/>

  <!-- ############################################################## -->

  <!-- I am sure there are cases where I violate Demeter's rule in a
       meaningful way, but seriously, complaining about access of
       elements in a collection passed to a method?! It is *natural*
       to create a bunch of classes that mutually peek inside each
       other. This rule should be removed because it catches way too
       much.
       <rule ref="rulesets/java/coupling.xml"/>
       -->

       <!-- ############################################################## -->

       <rule ref="rulesets/java/controversial.xml/UnnecessaryConstructor"/>
       <!-- This makes some sense, but not enough to be used.
            <rule ref="rulesets/java/controversial.xml/NullAssignment"/>
            -->
            <!-- Another layer of conditional code to have a single point of
                 return does not improve code quality, so we ignore this rule.
                 <rule ref="rulesets/java/controversial.xml/OnlyOneReturn"/>
                 -->
                 <!-- Unidentified rule.
                      <rule ref="rulesets/java/controversial.xml/UnusedModifier"/>
                 -->
                 <rule ref="rulesets/java/controversial.xml/AssignmentInOperand"/>
                 <rule ref="rulesets/java/controversial.xml/AtLeastOneConstructor"/>
                 <rule ref="rulesets/java/controversial.xml/DontImportSun"/>
                 <rule ref="rulesets/java/controversial.xml/SuspiciousOctalEscape"/>
                 <rule ref="rulesets/java/controversial.xml/CallSuperInConstructor"/>

                 <!--

CallSuperInConstructor
UnnecessaryParentheses
DefaultPackage
BooleanInversion
DataflowAnomalyAnalysis
AvoidFinalLocalVariable
AvoidUsingShortType
AvoidUsingVolatile
AvoidUsingNativeCode
AvoidAccessibilityAlteration
DoNotCallGarbageCollectionExplicitly
AvoidLiteralsInIfCondition
UseConcurrentHashMap

                 -->


                 <!-- ############################################################## -->

                 <rule ref="rulesets/java/codesize.xml/CyclomaticComplexity">
                   <properties>
                     <property name="reportLevel" value="11"/>

                     <!-- Each method that matches this pattern is automatically
                          generated. -->
                     <property name="violationSuppressRegex" value=".*MillerRabinTrial.*|.*trial.*|.*safeTrial.*"/>

                   </properties>
                 </rule>
                 <rule ref="rulesets/java/codesize.xml/NcssTypeCount">
                   <properties>

                     <!-- Each method that matches this pattern is automatically
                          generated. -->
                     <property name="violationSuppressRegex" value=".*trial.*|.*safeTrial.*"/>
                   </properties>
                 </rule>
                 <rule ref="rulesets/java/codesize.xml/NcssMethodCount">
                   <properties>

                     <!-- Each method that matches this pattern is automatically
                          generated. -->
                     <property name="violationSuppressRegex" value=".*MillerRabinTrial.*|.*trial.*|.*safeTrial.*"/>

                   </properties>
                 </rule>
                 <rule ref="rulesets/java/codesize.xml/NcssTypeCount">
                   <properties>

                     <!-- Each method of classes that matches this pattern is
                          automatically generated. -->
                     <property name="violationSuppressXPath" value=".[typeof('com.verificatum.arithm.MillerRabinTrial')]"/>

                   </properties>
                 </rule>
                 <!-- This rule makes no sense in a language like Java where
                      functions are grouped by classes, so we ignore it.
                      <rule ref="rulesets/java/codesize.xml/TooManyMethods"/>
                 -->

                 <!-- ############################################################## -->

                 <rule ref="rulesets/java/comments.xml/CommentRequired"/>
                 <!-- Long comments are long for a reason in Verificatum. The idea of
                      restricting the length of a comment in general is fundamentally
                      wrong. Furthermore, security critical code should be commented
                      carefully.
                      <rule ref="rulesets/java/comments.xml/CommentSize"/>
                 -->
                 <rule ref="rulesets/java/comments.xml/CommentContent"/>

                 <!-- ############################################################## -->

                 <rule ref="rulesets/java/design.xml/UseSingleton"/>
                 <rule ref="rulesets/java/design.xml/SimplifyBooleanReturns"/>
                 <rule ref="rulesets/java/design.xml/SimplifyBooleanExpressions"/>
                 <rule ref="rulesets/java/design.xml/SwitchStmtsShouldHaveDefault"/>
                 <rule ref="rulesets/java/design.xml/AvoidDeeplyNestedIfStmts"/>
                 <rule ref="rulesets/java/design.xml/AvoidReassigningParameters"/>
                 <rule ref="rulesets/java/design.xml/SwitchDensity"/>
                 <!-- This rule is stupid, so we ignore it. It is perfectly fine to
                      call an overridable function during construction.
                      <rule ref="rulesets/java/design.xml/ConstructorCallsOverridableMethod"/>
                 -->
                 <rule ref="rulesets/java/design.xml/AccessorClassGeneration"/>
                 <rule ref="rulesets/java/design.xml/FinalFieldCouldBeStatic"/>
                 <rule ref="rulesets/java/design.xml/CloseResource"/>
                 <rule ref="rulesets/java/design.xml/NonStaticInitializer"/>
                 <rule ref="rulesets/java/design.xml/DefaultLabelNotLastInSwitchStmt"/>
                 <rule ref="rulesets/java/design.xml/NonCaseLabelInSwitchStatement"/>
                 <rule ref="rulesets/java/design.xml/OptimizableToArrayCall"/>
                 <rule ref="rulesets/java/design.xml/EqualsNull"/>
                 <rule ref="rulesets/java/design.xml/ConfusingTernary"/>
                 <rule ref="rulesets/java/design.xml/InstantiationToGetClass"/>
                 <rule ref="rulesets/java/design.xml/IdempotentOperations"/>
                 <rule ref="rulesets/java/design.xml/SimpleDateFormatNeedsLocale"/>
                 <rule ref="rulesets/java/design.xml/ImmutableField"/>
                 <rule ref="rulesets/java/design.xml/UseLocaleWithCaseConversions"/>
                 <rule ref="rulesets/java/design.xml/AvoidProtectedFieldInFinalClass"/>
                 <rule ref="rulesets/java/design.xml/AssignmentToNonFinalStatic"/>
                 <rule ref="rulesets/java/design.xml/MissingStaticMethodInNonInstantiatableClass"/>
                 <rule ref="rulesets/java/design.xml/AvoidSynchronizedAtMethodLevel"/>
                 <rule ref="rulesets/java/design.xml/MissingBreakInSwitch"/>
                 <rule ref="rulesets/java/design.xml/UseNotifyAllInsteadOfNotify"/>
                 <rule ref="rulesets/java/design.xml/AvoidInstanceofChecksInCatchClause"/>
                 <rule ref="rulesets/java/design.xml/AbstractClassWithoutAbstractMethod"/>
                 <rule ref="rulesets/java/design.xml/SimplifyConditional"/>
                 <rule ref="rulesets/java/design.xml/SimplifyConditional"/>
                 <rule ref="rulesets/java/design.xml/PositionLiteralsFirstInComparisons"/>
                 <rule ref="rulesets/java/design.xml/UnnecessaryLocalBeforeReturn"/>
                 <rule ref="rulesets/java/design.xml/NonThreadSafeSingleton"/>
                 <!-- This test is implemented incorrectly, so we ignore it.
                      <rule ref="rulesets/java/design.xml/UncommentedEmptyMethod"/>
                      -->
                      <rule ref="rulesets/java/design.xml/UncommentedEmptyConstructor"/>
                      <rule ref="rulesets/java/design.xml/AvoidConstantsInterface"/>
                      <rule ref="rulesets/java/design.xml/UnsynchronizedStaticDateFormatter"/>
                      <rule ref="rulesets/java/design.xml/PreserveStackTrace"/>
                      <rule ref="rulesets/java/design.xml/UseCollectionIsEmpty"/>
                      <rule ref="rulesets/java/design.xml/ClassWithOnlyPrivateConstructorsShouldBeFinal"/>
                      <rule ref="rulesets/java/design.xml/EmptyMethodInAbstractClassShouldBeAbstract"/>
                      <!-- This only gives a small number of false positives with no
                           possibilities to filter out specific classes.
                           <rule ref="rulesets/java/design.xml/SingularField">
                      -->
                      <rule ref="rulesets/java/design.xml/ReturnEmptyArrayRatherThanNull"/>
                      <rule ref="rulesets/java/design.xml/AbstractClassWithoutAnyMethod"/>
                      <rule ref="rulesets/java/design.xml/TooFewBranchesForASwitchStatement"/>

                      <!-- ############################################################## -->

                      <rule ref="rulesets/java/empty.xml"/>

                      <!-- ############################################################## -->

                      <rule ref="rulesets/java/finalizers.xml"/>

                      <!-- ############################################################## -->

                      <rule ref="rulesets/java/imports.xml"/>

                      <!-- ############################################################## -->

                      <!-- These rules are stupid, so we ignore it. Short variable names
                           are often natural.
                           <rule ref="rulesets/java/naming.xml/ShortVariable"/>
                      -->
                      <!-- These rules are stupid, so we ignore it. Long variable names
                           are often natural.
                           <rule ref="rulesets/java/naming.xml/LongVariable"/>
                      -->
                      <rule ref="rulesets/java/naming.xml/ShortMethodName"/>
                      <rule ref="rulesets/java/naming.xml/VariableNamingConventions"/>
                      <rule ref="rulesets/java/naming.xml/MethodNamingConventions"/>
                      <rule ref="rulesets/java/naming.xml/ClassNamingConventions"/>
                      <!-- This rule is stupid, so we ignore it. It makes no sense to
                           force all abstract classes to use "Abstract" as a prefix.
                           <rule ref="rulesets/java/naming.xml/AbstractNaming"/>
                      -->
                      <rule ref="rulesets/java/naming.xml/AvoidDollarSigns"/>
                      <rule ref="rulesets/java/naming.xml/MethodWithSameNameAsEnclosingClass"/>
                      <rule ref="rulesets/java/naming.xml/SuspiciousHashcodeMethodName"/>
                      <!-- This is a subset of the reverse of VariableNamingConventions,
                           so we ignore it.
                           <rule ref="rulesets/java/naming.xml/SuspiciousConstantFieldName"/>
                      -->
                      <rule ref="rulesets/java/naming.xml/SuspiciousEqualsMethodName"/>
                      <rule ref="rulesets/java/naming.xml/AvoidFieldNameMatchingTypeName"/>
                      <!-- This is incorrectly implemented, so we ignore it.
                           <rule ref="rulesets/java/naming.xml/AvoidFieldNameMatchingMethodName"/>
                      -->
                      <!-- This is incorrectly implemented, so we ignore it.
                           <rule ref="rulesets/java/naming.xml/NoPackage"/>
                      -->
                      <rule ref="rulesets/java/naming.xml/PackageCase"/>
                      <rule ref="rulesets/java/naming.xml/MisleadingVariableName"/>
                      <!-- This is incorrectly implemented, so we ignore it.
                           <rule ref="rulesets/java/naming.xml/BooleanGetMethodName"/>
                      -->
                      <rule ref="rulesets/java/naming.xml/GenericsNaming"/>

                      <!-- ############################################################## -->

                      <rule ref="rulesets/java/optimizations.xml/LocalVariableCouldBeFinal"/>

                      <!-- ############################################################## -->

                      <rule ref="rulesets/java/optimizations.xml/MethodArgumentCouldBeFinal"/>
                      <!-- This is a stupid rule, so we ignore it. It is natural to
                           instantiate objects in loops.
                           <rule ref="rulesets/java/optimizations.xml/AvoidInstantiatingObjectsInLoops"/>
                      -->
                      <rule ref="rulesets/java/optimizations.xml/UseArrayListInsteadOfVector"/>
                      <rule ref="rulesets/java/optimizations.xml/SimplifyStartsWith"/>
                      <rule ref="rulesets/java/optimizations.xml/UseStringBufferForStringAppends"/>
                      <rule ref="rulesets/java/optimizations.xml/UseArraysAsList"/>
                      <rule ref="rulesets/java/optimizations.xml/AvoidArrayLoops"/>
                      <rule ref="rulesets/java/optimizations.xml/UnnecessaryWrapperObjectCreation"/>
                      <rule ref="rulesets/java/optimizations.xml/AddEmptyString"/>

                      <!-- ############################################################## -->

                      <rule ref="rulesets/java/sunsecure.xml"/>

                      <!-- ############################################################## -->

                      <rule ref="rulesets/java/strings.xml/AvoidDuplicateLiterals">
                        <properties>

                          <!-- We filter out repetitions of information and error texts as
                               well as command line flags and boolean files.-->
                          <property name="violationSuppressRegex" value=".*(\\n)+.*|.*-.*|.*(  )+.*|.*\..*"/>

                        </properties>
                      </rule>
                      <rule ref="rulesets/java/strings.xml/StringInstantiation"/>
                      <rule ref="rulesets/java/strings.xml/StringToString"/>
                      <rule ref="rulesets/java/strings.xml/InefficientStringBuffering"/>
                      <rule ref="rulesets/java/strings.xml/UnnecessaryCaseChange"/>
                      <rule ref="rulesets/java/strings.xml/UseStringBufferLength"/>
                      <rule ref="rulesets/java/strings.xml/AppendCharacterWithChar"/>

                    </ruleset>
